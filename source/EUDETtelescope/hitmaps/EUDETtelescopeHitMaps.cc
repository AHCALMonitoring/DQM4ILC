/// \file EUDETtelescopeHitMaps.cc
/*
 *
 * EUDETtelescopeHitMaps.cc source template automatically generated by a class generator
 * Creation date : tue. sep. 27 2016
 *
 * This file is part of DQM4HEP libraries.
 * 
 * DQM4HEP is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 * based upon these libraries are permitted. Any copy of these libraries
 * must include this copyright notice.
 * 
 * DQM4HEP is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with DQM4HEP.  If not, see <http://www.gnu.org/licenses/>.
 * 
 * @author A. Irles,
 * based on Remi Ete code @copyright CNRS , IPNL
 */

#include "EUDETtelescopeHitMaps.h"

// -- std headers
#include <ctime>
#include <cstdlib>
#include <limits>

// -- lcio headers
#include "EVENT/TrackerData.h"
#include "EVENT/LCCollection.h"
#include "EVENT/LCEvent.h"
#include "EVENT/LCIO.h"
#include "UTIL/CellIDDecoder.h"
#include "UTIL/LCTOOLS.h"

// -- dqm4hep headers
#include "dqm4hep/DQMMonitorElement.h"
#include "dqm4hep/DQMCoreTool.h"
#include "dqm4hep/DQMRun.h"
#include "dqm4hep/DQMXmlHelper.h"
#include "dqm4hep/DQMEvent.h"
#include "dqm4hep/DQMQualityTest.h"
#include "dqm4hep/DQMModuleApi.h"
#include "dqm4hep/DQMPlugin.h"

// -- root headers
#include "TRandom.h"

namespace dqm4hep
{
  // module plugin declaration
  DQM_PLUGIN_DECL( EUDETtelescopeHitMaps , "EUDETtelescopeHitMaps" )

  //-------------------------------------------------------------------------------------------------

  EUDETtelescopeHitMaps::EUDETtelescopeHitMaps() :
  DQMAnalysisModule()
  {
    setDetectorName("NO DETECTOR");
    setVersion(1, 0, 0);
  }

  //-------------------------------------------------------------------------------------------------

  EUDETtelescopeHitMaps::~EUDETtelescopeHitMaps()
  {
  }

  //-------------------------------------------------------------------------------------------------

  StatusCode EUDETtelescopeHitMaps::readSettings(const TiXmlHandle xmlHandle)
  {
    LOG4CXX_INFO( dqmMainLogger , "Module : " << getName() << " -- readSettings()" );

    // ----------------------------
    // Hot pixels Map
    // ----------------------------

    std::string m_hotpixelsFilename = "";

    RETURN_RESULT_IF_AND_IF(STATUS_CODE_SUCCESS, STATUS_CODE_NOT_FOUND, !=, DQMXmlHelper::readParameterValue(xmlHandle,
                                                                                                             "HotPixelsFilename", m_hotpixelsFilename));

    dqm4hep::TiXmlDocument m_hotpixelsFile(m_hotpixelsFilename);
    
    if( ! m_hotpixelsFile.LoadFile() )
      return dqm4hep::STATUS_CODE_FAILURE;

     const dqm4hep::TiXmlHandle xmlGeometryFileHandle(&m_hotpixelsFile);

     RETURN_RESULT_IF_AND_IF(STATUS_CODE_SUCCESS, STATUS_CODE_NOT_FOUND, !=, EUDETtelescopeHitMaps::buildHotPixelsMap(xmlGeometryFileHandle));

    // ----------------------------

    m_pX2 = NULL;
    m_pX3 = NULL;
    m_pX4 = NULL;
    m_pX5 = NULL;
    m_pX6 = NULL;
    RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, DQMXmlHelper::bookMonitorElement(this, xmlHandle,"profileX2", m_pX2));
    RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, DQMXmlHelper::bookMonitorElement(this, xmlHandle,"profileX3", m_pX3));
    RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, DQMXmlHelper::bookMonitorElement(this, xmlHandle,"profileX4", m_pX4));
    RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, DQMXmlHelper::bookMonitorElement(this, xmlHandle,"profileX5", m_pX5));
    RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, DQMXmlHelper::bookMonitorElement(this, xmlHandle,"profileX6", m_pX6));

    m_pY2 = NULL;
    m_pY3 = NULL;
    m_pY4 = NULL;
    m_pY5 = NULL;
    m_pY6 = NULL;
    RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, DQMXmlHelper::bookMonitorElement(this, xmlHandle,"profileY2", m_pY2));
    RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, DQMXmlHelper::bookMonitorElement(this, xmlHandle,"profileY3", m_pY3));
    RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, DQMXmlHelper::bookMonitorElement(this, xmlHandle,"profileY4", m_pY4));
    RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, DQMXmlHelper::bookMonitorElement(this, xmlHandle,"profileY5", m_pY5));
    RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, DQMXmlHelper::bookMonitorElement(this, xmlHandle,"profileY6", m_pY6));

    m_pHitMap1 = NULL;
    m_pHitMap2 = NULL;
    m_pHitMap3 = NULL;
    m_pHitMap4 = NULL;
    m_pHitMap5 = NULL;
    m_pHitMap6 = NULL;
    RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, DQMXmlHelper::bookMonitorElement(this, xmlHandle,"HitMap1", m_pHitMap1));
    RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, DQMXmlHelper::bookMonitorElement(this, xmlHandle,"HitMap2", m_pHitMap2));
    RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, DQMXmlHelper::bookMonitorElement(this, xmlHandle,"HitMap3", m_pHitMap3));
    RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, DQMXmlHelper::bookMonitorElement(this, xmlHandle,"HitMap4", m_pHitMap4));
    RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, DQMXmlHelper::bookMonitorElement(this, xmlHandle,"HitMap5", m_pHitMap5));
    RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, DQMXmlHelper::bookMonitorElement(this, xmlHandle,"HitMap6", m_pHitMap6));

    m_dumpEvent = false;
    RETURN_RESULT_IF_AND_IF(STATUS_CODE_SUCCESS, STATUS_CODE_NOT_FOUND, !=, DQMXmlHelper::readParameterValue(xmlHandle,
													     "DumpEvent", m_dumpEvent));

    return STATUS_CODE_SUCCESS;
  }

  //-------------------------------------------------------------------------------------------------

  StatusCode EUDETtelescopeHitMaps::initModule()
  {
    LOG4CXX_INFO( dqmMainLogger , "Module : " << getName() << " -- init()" );

    // print directory structure of monitor element storage in console
    DQMModuleApi::cd(this);
    DQMModuleApi::ls(this, true);

    return STATUS_CODE_SUCCESS;
  }

  //-------------------------------------------------------------------------------------------------

  StatusCode EUDETtelescopeHitMaps::endModule()
  {
    LOG4CXX_INFO( dqmMainLogger , "Module : " << getName() << " -- end()" );
    return STATUS_CODE_SUCCESS;
  }

  //-------------------------------------------------------------------------------------------------

  StatusCode EUDETtelescopeHitMaps::processEvent(DQMEvent *pEvent)
  {
    EVENT::LCEvent *pLCEvent = pEvent->getEvent<EVENT::LCEvent>();

    if(!pLCEvent)
      return STATUS_CODE_FAILURE;

    if(m_dumpEvent)
      UTIL::LCTOOLS::dumpEvent(pLCEvent);

    const std::vector<std::string> *pCollectionNames = pLCEvent->getCollectionNames();


    for(std::vector<std::string>::const_iterator colIter = pCollectionNames->begin(), colEndIter = pCollectionNames->end() ;
	colEndIter != colIter ; ++colIter)
      {
	const std::string &collectionName(*colIter);

	EVENT::LCCollection *pLCCollection = pLCEvent->getCollection(collectionName);

	if(pLCCollection->getTypeName() == EVENT::LCIO::TRACKERDATA)
	  {
	    UTIL::CellIDDecoder<EVENT::TrackerData> cellIdDecoder(pLCCollection);

	    const int nElements = pLCCollection->getNumberOfElements();

	    const EVENT::TrackerData *const pEUDETtelescopeHitMaps_1 = dynamic_cast<const EVENT::TrackerData *const>(pLCCollection->getElementAt(0));

	    if(NULL == pEUDETtelescopeHitMaps_1)
	      continue;

	    for(int i=0; i< pEUDETtelescopeHitMaps_1->getChargeValues().size(); i+=4) {

	      double x_1 = pEUDETtelescopeHitMaps_1->getChargeValues().at(i);
	      double y_1 = pEUDETtelescopeHitMaps_1->getChargeValues().at(i+1);
	      bool hotpix=false;

	      for (std::map<int,int>::iterator it=hotpixelsMap[0].begin(); it!=hotpixelsMap[0].end(); ++it) 
		if( x_1 == it->first && y_1==it->second) hotpix=true;

	      m_pHitMap1->get<TH2I>()->Fill(x_1, y_1);


	      if(hotpix==false) {
		
	      for(int e=1 ; e<nElements ; e++)
		{
		  const EVENT::TrackerData *const pEUDETtelescopeHitMaps = dynamic_cast<const EVENT::TrackerData *const>(pLCCollection->getElementAt(e));
			      
		  if(NULL == pEUDETtelescopeHitMaps)
		    continue;
			      
		  for(int i=0; i< pEUDETtelescopeHitMaps->getChargeValues().size(); i+=4) {
		    double x = pEUDETtelescopeHitMaps->getChargeValues().at(i);
		    double y = pEUDETtelescopeHitMaps->getChargeValues().at(i+1);

		    hotpix=false;

		    for (std::map<int,int>::iterator it=hotpixelsMap[e].begin(); it!=hotpixelsMap[e].end(); ++it) 
		      if( x == it->first && y == it->second) hotpix=true;
				
		    if(hotpix==false){ 
		      
		      if(e==1) m_pX2->get<TH2I>()->Fill(x_1, x);
		      if(e==2) m_pX3->get<TH2I>()->Fill(x_1, x);
		      if(e==3) m_pX4->get<TH2I>()->Fill(x_1, x);
		      if(e==4) m_pX5->get<TH2I>()->Fill(x_1, x);
		      if(e==5) m_pX6->get<TH2I>()->Fill(x_1, x);
		      
		      if(e==1) m_pY2->get<TH2I>()->Fill(y_1, y);
		      if(e==2) m_pY3->get<TH2I>()->Fill(y_1, y);
		      if(e==3) m_pY4->get<TH2I>()->Fill(y_1, y);
		      if(e==4) m_pY5->get<TH2I>()->Fill(y_1, y);
		      if(e==5) m_pY6->get<TH2I>()->Fill(y_1, y);
 
		      if(e==1) m_pHitMap2->get<TH2I>()->Fill(x, y);
		      if(e==2) m_pHitMap3->get<TH2I>()->Fill(x, y);
		      if(e==3) m_pHitMap4->get<TH2I>()->Fill(x, y);
		      if(e==4) m_pHitMap5->get<TH2I>()->Fill(x, y);
		      if(e==5) m_pHitMap6->get<TH2I>()->Fill(x, y);

		    }
				
		  }
		}
	      }
			  
	    }
	  }
      }


    return STATUS_CODE_SUCCESS;
  }

  //-------------------------------------------------------------------------------------------------

  StatusCode EUDETtelescopeHitMaps::startOfCycle()
  {
    LOG4CXX_INFO( dqmMainLogger , "Module : " << getName() << " -- startOfCycle()" );
    return STATUS_CODE_SUCCESS;
  }

  //-------------------------------------------------------------------------------------------------

  StatusCode EUDETtelescopeHitMaps::endOfCycle()
  {
    LOG4CXX_INFO( dqmMainLogger , "Module : " << getName() << " -- endOfCycle()" );

    // run all quality tests on all monitor elements
    RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, DQMModuleApi::runQualityTests(this));

    return STATUS_CODE_SUCCESS;
  }

  //-------------------------------------------------------------------------------------------------

  StatusCode EUDETtelescopeHitMaps::startOfRun(DQMRun *pRun)
  {
    LOG4CXX_INFO( dqmMainLogger , "Module : " << getName() << " -- startOfRun()" );
    LOG4CXX_INFO( dqmMainLogger , "Run no " << pRun->getRunNumber() );
    time_t startTime = std::chrono::system_clock::to_time_t(pRun->getStartTime());

    std::string timeStr;
    DQMCoreTool::timeToHMS(startTime, timeStr);

    LOG4CXX_INFO( dqmMainLogger , "Start time " << timeStr );
    LOG4CXX_INFO( dqmMainLogger , "Detector is " << pRun->getDetectorName() );
    LOG4CXX_INFO( dqmMainLogger , "Description " << pRun->getDescription() );

    return STATUS_CODE_SUCCESS;
  }

  //-------------------------------------------------------------------------------------------------

  StatusCode EUDETtelescopeHitMaps::endOfRun(DQMRun *pRun)
  {
    LOG4CXX_INFO( dqmMainLogger , "Module : " << getName() << " -- endOfRun()" );
    LOG4CXX_INFO( dqmMainLogger , "Run no " << pRun->getRunNumber() );

    time_t endTime = std::chrono::system_clock::to_time_t(pRun->getEndTime());
    std::string timeStr;
    DQMCoreTool::timeToHMS(endTime, timeStr);

    LOG4CXX_INFO( dqmMainLogger , "End time " << timeStr );

    return STATUS_CODE_SUCCESS;
  }


  StatusCode EUDETtelescopeHitMaps::buildHotPixelsMap(const TiXmlHandle xmlHandle)
  {

    LOG4CXX_INFO( dqmMainLogger , "Building Hot Pixels map..." );

    //Getting the very first child of the XML file; in our case, this is the dqm4hepGeometryMap bracket.
    const dqm4hep::TiXmlHandle xmlFileHandle(xmlHandle.FirstChildElement().Element());

    //Iterate over each layer
    for (dqm4hep::TiXmlElement *pSensorXmlElement = xmlFileHandle.FirstChild("sensor").Element(); NULL != pSensorXmlElement; pSensorXmlElement = pSensorXmlElement->NextSiblingElement("sensor"))
      {

	dqm4hep::TiXmlHandle pSensorHandle(pSensorXmlElement);

	//Iterate over each pixel
	for (dqm4hep::TiXmlElement *pPixelXmlElement = pSensorHandle.FirstChild("pixel").Element(); NULL != pPixelXmlElement; pPixelXmlElement = pPixelXmlElement->NextSiblingElement("pixel"))
	  {

	    dqm4hep::TiXmlHandle pPixelHandle(pPixelXmlElement);

	    int SensorID, pixelX, pixelY;

		//Pull out all the data: pixel number, channel number, ijk
		pSensorXmlElement->QueryValueAttribute<int>("id", &SensorID);
		pPixelXmlElement->QueryValueAttribute<int>("x", &pixelX);
		pPixelXmlElement->QueryValueAttribute<int>("y", &pixelY);

		if(SensorID==1) hotpixelsmap1.insert(std::make_pair(pixelX, pixelY));
		if(SensorID==2) hotpixelsmap2.insert(std::make_pair(pixelX, pixelY));
		if(SensorID==3) hotpixelsmap3.insert(std::make_pair(pixelX, pixelY));
		if(SensorID==4) hotpixelsmap4.insert(std::make_pair(pixelX, pixelY));
		if(SensorID==5) hotpixelsmap5.insert(std::make_pair(pixelX, pixelY));
		if(SensorID==6) hotpixelsmap6.insert(std::make_pair(pixelX, pixelY));


	  }
	  
      }

    std::cout<<hotpixelsmap1.size()<<std::endl;
    std::cout<<hotpixelsmap2.size()<<std::endl;
    std::cout<<hotpixelsmap3.size()<<std::endl;
    std::cout<<hotpixelsmap4.size()<<std::endl;
    std::cout<<hotpixelsmap5.size()<<std::endl;
    std::cout<<hotpixelsmap6.size()<<std::endl;
    hotpixelsMap.push_back(hotpixelsmap1);
    hotpixelsMap.push_back(hotpixelsmap2);
    hotpixelsMap.push_back(hotpixelsmap3);
    hotpixelsMap.push_back(hotpixelsmap4);
    hotpixelsMap.push_back(hotpixelsmap5);
    hotpixelsMap.push_back(hotpixelsmap6);

    LOG4CXX_INFO( dqmMainLogger , "Geometry map built successfully." );

    return STATUS_CODE_SUCCESS;

  }


} 

