/// \file EUDETtelescopeHotPixels.cc
/*
 *
 * EUDETtelescopeHotPixels.cc source template automatically generated by a class generator
 * Creation date : tue. sep. 27 2016
 *
 * This file is part of DQM4HEP libraries.
 * 
 * DQM4HEP is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 * based upon these libraries are permitted. Any copy of these libraries
 * must include this copyright notice.
 * 
 * DQM4HEP is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with DQM4HEP.  If not, see <http://www.gnu.org/licenses/>.
 * 
 * @author A. Irles,
 * based on Remi Ete code @copyright CNRS , IPNL
 */

#include "EUDETtelescopeHotPixels.h"

// -- std headers
#include <ctime>
#include <cstdlib>
#include <limits>

// -- lcio headers
#include "EVENT/TrackerData.h"
#include "EVENT/LCCollection.h"
#include "EVENT/LCEvent.h"
#include "EVENT/LCIO.h"
#include "UTIL/CellIDDecoder.h"
#include "UTIL/LCTOOLS.h"

// -- dqm4hep headers
#include "dqm4hep/DQMMonitorElement.h"
#include "dqm4hep/DQMCoreTool.h"
#include "dqm4hep/DQMRun.h"
#include "dqm4hep/DQMXmlHelper.h"
#include "dqm4hep/DQMEvent.h"
#include "dqm4hep/DQMQualityTest.h"
#include "dqm4hep/DQMModuleApi.h"
#include "dqm4hep/DQMPlugin.h"

// -- root headers
#include "TRandom.h"

namespace dqm4hep
{
  // module plugin declaration
  DQM_PLUGIN_DECL( EUDETtelescopeHotPixels , "EUDETtelescopeHotPixels" )

  //-------------------------------------------------------------------------------------------------

  EUDETtelescopeHotPixels::EUDETtelescopeHotPixels() :
  DQMAnalysisModule()
  {
    setDetectorName("NO DETECTOR");
    setVersion(1, 0, 0);
  }

  //-------------------------------------------------------------------------------------------------

  EUDETtelescopeHotPixels::~EUDETtelescopeHotPixels()
  {
  }

  //-------------------------------------------------------------------------------------------------

  StatusCode EUDETtelescopeHotPixels::readSettings(const TiXmlHandle xmlHandle)
  {
    LOG4CXX_INFO( dqmMainLogger , "Module : " << getName() << " -- readSettings()" );

    m_pHotPix1 = NULL;
    m_pHotPix2 = NULL;
    m_pHotPix3 = NULL;
    m_pHotPix4 = NULL;
    m_pHotPix5 = NULL;
    m_pHotPix6 = NULL;
    RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, DQMXmlHelper::bookMonitorElement(this, xmlHandle,"HotPix1", m_pHotPix1));
    RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, DQMXmlHelper::bookMonitorElement(this, xmlHandle,"HotPix2", m_pHotPix2));
    RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, DQMXmlHelper::bookMonitorElement(this, xmlHandle,"HotPix3", m_pHotPix3));
    RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, DQMXmlHelper::bookMonitorElement(this, xmlHandle,"HotPix4", m_pHotPix4));
    RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, DQMXmlHelper::bookMonitorElement(this, xmlHandle,"HotPix5", m_pHotPix5));
    RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, DQMXmlHelper::bookMonitorElement(this, xmlHandle,"HotPix6", m_pHotPix6));

     m_dumpEvent = false;
    RETURN_RESULT_IF_AND_IF(STATUS_CODE_SUCCESS, STATUS_CODE_NOT_FOUND, !=, DQMXmlHelper::readParameterValue(xmlHandle,
													     "DumpEvent", m_dumpEvent));

    plane_map_array = new int *[1152];
    if (plane_map_array != NULL) {
      for (int j = 0; j < 1152; j++) {
        plane_map_array[j] = new int[576];
      }
    }

    for (int i = 0; i < 1152; i++) {
      for (int j = 0; j < 576; j++) {
	plane_map_array[i][j] = 0;
      }
    }

    currentEventNum = 0;

    return STATUS_CODE_SUCCESS;
  }

  //-------------------------------------------------------------------------------------------------

  StatusCode EUDETtelescopeHotPixels::initModule()
  {
    LOG4CXX_INFO( dqmMainLogger , "Module : " << getName() << " -- init()" );

    // print directory structure of monitor element storage in console
    DQMModuleApi::cd(this);
    DQMModuleApi::ls(this, true);

    return STATUS_CODE_SUCCESS;
  }

  //-------------------------------------------------------------------------------------------------

  StatusCode EUDETtelescopeHotPixels::endModule()
  {
    LOG4CXX_INFO( dqmMainLogger , "Module : " << getName() << " -- end()" );
    return STATUS_CODE_SUCCESS;
  }

  //-------------------------------------------------------------------------------------------------

  StatusCode EUDETtelescopeHotPixels::processEvent(DQMEvent *pEvent)
  {
    EVENT::LCEvent *pLCEvent = pEvent->getEvent<EVENT::LCEvent>();

    if(!pLCEvent)
      return STATUS_CODE_FAILURE;

    if(m_dumpEvent)
      UTIL::LCTOOLS::dumpEvent(pLCEvent);

    const std::vector<std::string> *pCollectionNames = pLCEvent->getCollectionNames();


    for(std::vector<std::string>::const_iterator colIter = pCollectionNames->begin(), colEndIter = pCollectionNames->end() ;
	colEndIter != colIter ; ++colIter)
      {
	const std::string &collectionName(*colIter);

	EVENT::LCCollection *pLCCollection = pLCEvent->getCollection(collectionName);

	double bin =0;
	double occupancy =0;

	if(pLCCollection->getTypeName() == EVENT::LCIO::TRACKERDATA)
	  {
	    UTIL::CellIDDecoder<EVENT::TrackerData> cellIdDecoder(pLCCollection);

	    const int nElements = pLCCollection->getNumberOfElements();

	    currentEventNum++;

	      for(int e=0 ; e<nElements ; e++)
		{
		  const EVENT::TrackerData *const pEUDETtelescopeHotPixels = dynamic_cast<const EVENT::TrackerData *const>(pLCCollection->getElementAt(e));
			      
		  if(NULL == pEUDETtelescopeHotPixels)
		    continue;

		  for(int i=0; i< pEUDETtelescopeHotPixels->getChargeValues().size(); i+=4) {

		    int x = pEUDETtelescopeHotPixels->getChargeValues().at(i);
		    int y = pEUDETtelescopeHotPixels->getChargeValues().at(i+1);

		    plane_map_array[x][y] = plane_map_array[x][y] + 1;
		  }

		  for (int x = 0; x < 1152; ++x) {
		    for (int y = 0; y < 576; ++y) {
		      bin = plane_map_array[x][y];
		      double Hotpixelcut_1 =0.95;
		      double Hotpixelcut_2 = 1/100;

		      if( bin != 0) {
			occupancy = bin / (double)currentEventNum;
			if (currentEventNum > 100)  {
			  if(e==0) m_pHotPix1->get<TH2I>()->Fill(x, y, occupancy);
			  if(e==1) m_pHotPix2->get<TH2I>()->Fill(x, y, occupancy);
			  if(e==2) m_pHotPix3->get<TH2I>()->Fill(x, y, occupancy);
			  if(e==3) m_pHotPix4->get<TH2I>()->Fill(x, y, occupancy);
			  if(e==4) m_pHotPix5->get<TH2I>()->Fill(x, y, occupancy);
			  if(e==5) m_pHotPix6->get<TH2I>()->Fill(x, y, occupancy);
			}
		      }
		    }
		  }

	
		}
	  }
      }


    return STATUS_CODE_SUCCESS;
  }

  //-------------------------------------------------------------------------------------------------

  StatusCode EUDETtelescopeHotPixels::startOfCycle()
  {
    LOG4CXX_INFO( dqmMainLogger , "Module : " << getName() << " -- startOfCycle()" );
    return STATUS_CODE_SUCCESS;
  }

  //-------------------------------------------------------------------------------------------------

  StatusCode EUDETtelescopeHotPixels::endOfCycle()
  {
    LOG4CXX_INFO( dqmMainLogger , "Module : " << getName() << " -- endOfCycle()" );

    // run all quality tests on all monitor elements
    RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, DQMModuleApi::runQualityTests(this));

    return STATUS_CODE_SUCCESS;
  }

  //-------------------------------------------------------------------------------------------------

  StatusCode EUDETtelescopeHotPixels::startOfRun(DQMRun *pRun)
  {
    LOG4CXX_INFO( dqmMainLogger , "Module : " << getName() << " -- startOfRun()" );
    LOG4CXX_INFO( dqmMainLogger , "Run no " << pRun->getRunNumber() );
    time_t startTime = std::chrono::system_clock::to_time_t(pRun->getStartTime());

    std::string timeStr;
    DQMCoreTool::timeToHMS(startTime, timeStr);

    LOG4CXX_INFO( dqmMainLogger , "Start time " << timeStr );
    LOG4CXX_INFO( dqmMainLogger , "Detector is " << pRun->getDetectorName() );
    LOG4CXX_INFO( dqmMainLogger , "Description " << pRun->getDescription() );

    return STATUS_CODE_SUCCESS;
  }

  //-------------------------------------------------------------------------------------------------

  StatusCode EUDETtelescopeHotPixels::endOfRun(DQMRun *pRun)
  {
    LOG4CXX_INFO( dqmMainLogger , "Module : " << getName() << " -- endOfRun()" );
    LOG4CXX_INFO( dqmMainLogger , "Run no " << pRun->getRunNumber() );

    std::cout<< "<dqm4hepHotPixelsMap>"<< std::endl;
    for (int sensor =0; sensor < 6; sensor ++) {
      std::cout<< "<sensor id=\""<<sensor+1<<"\""<< std::endl;
      
      for (int x = 0; x < 1152; ++x) {
	for (int y = 0; y < 576; ++y) {
	  bool hotpixel = false;
	  if(sensor==0 && m_pHotPix1->get<TH2I>()->GetBinContent(x, y) > 0 ) hotpixel=true;
	  if(sensor==1 && m_pHotPix2->get<TH2I>()->GetBinContent(x, y) > 0 ) hotpixel=true;
	  if(sensor==2 && m_pHotPix3->get<TH2I>()->GetBinContent(x, y) > 0 ) hotpixel=true;
	  if(sensor==3 && m_pHotPix4->get<TH2I>()->GetBinContent(x, y) > 0 ) hotpixel=true;
	  if(sensor==4 && m_pHotPix5->get<TH2I>()->GetBinContent(x, y) > 0 ) hotpixel=true;
	  if(sensor==5 && m_pHotPix6->get<TH2I>()->GetBinContent(x, y) > 0 ) hotpixel=true;

	  if(hotpixel == true) std::cout<< "<pixel x=\""<<x<<"\"  y=\""<<y<<"\"\/>"<< std::endl;
	}
      }
      std::cout<< "<\/sensor>"<< std::endl;
    }     

    std::cout<< "<\/dqm4hepHotPixelsMap>"<< std::endl;

    
    time_t endTime = std::chrono::system_clock::to_time_t(pRun->getEndTime());
    std::string timeStr;
    DQMCoreTool::timeToHMS(endTime, timeStr);
 		  
    LOG4CXX_INFO( dqmMainLogger , "End time " << timeStr );

    return STATUS_CODE_SUCCESS;
  }

} 

